% Komponentendiagramm des Projektes
\section{Komponentendiagramm}

%% img component_diagram.png

Das Projekt ist in 6 Komponenten aufgeteilt. 
\begin{itemize}
	\item Core
	\item Graphical User Interface (GUI)
	\item Database Persistence (DAO)
	\item Synchronisation Services
	\item File System Services
	\item Network Service
\end{itemize}

%------------------------------------------------
%-------------- Disclaimer ----------------------
%------------------------------------------------
% Wie man sieht habe ich sehr viel dazugeschrieben. Allgemein ist mein Verständnis von einer Komponente das, dass ich von ihr wissen will, wofür ich sie nutzen kann und was sie mir für Services anbietet.

\subsection{Core}
In der Core-Komponente befindet sich die Business Logic der Applikation. Hier wird entschieden, was bei bestimmten User-Eingaben (z.B. das Drücken des Buttons ``Synchronisieren") gemacht werden soll. % Die direkte User Interaktion gehört imo in die gui und nicht in den core. Der core macht nur dataprocessing.
Die Core Komponente deligiert die vom User gewünschte Aktion an die einzelnen Komponenten, % Der Core deligiert nicht er verwendet die komponenten. Die Komponenten stellen nur ein Service zur Verfügung das genutzt werden kann interessieren sich aber selbst nicht für die Tasks.
fügt die Ergebnisse der Aktionen zusammen und gibt diese zurück an die GUI. % hmmm, bin mir nicht sicher, werden die daten an die gui gepusht, oder sagt man der gui nur; es gibt was neues pull die neuen daten?
Der Core reagiert aber auch auf Events, die durch die einzelnen Komponenten gemeldet werden, z.B. wenn eine Datei im Dateisystem geändert wird, wird dies über den Core an die GUI gemeldet und je nach User Interaktion weiter an die Synchronisationskomponente geleitet. % Der Core leitet keine Events direkt an die gui weiter. Sonst würde die gui indirekt mit den anderen Komponenten verbunden sein, und deren interfaces kennen. So kennt die gui NUR den Core. Wenn Events auftreten werde sie vom Core verarbeitet und eventuell ein neues Event an die gui gesendet. 

\subsection{Graphical User Interface}
Das Graphical User Interface (GUI) ist die grafische Benutzeroberfläche, mit welcher der Endanwender arbeitet.
Die GUI ermöglicht Zugriff auf alle von der ``Core"-Komponente für Endbenutzer zur Verfügung gestellten
Funktionalitäten.

\subsection{Database Persistence} % Persistence NICHT Database Persistence, es ist nicht festgelegt dass wir eine Datenbank verwenden
Die Database Persistence Komponente abstrahiert den Zugriff auf die Datenbank und ermöglicht es, definierte
Aktionen einfach und geregelt (z.B. mittels Transaktionen) % Keine implementierungsdetails in den Komponenten!
auszuführen. Es wird das Konzept des Data Hiding umgesetzt, wodurch erreicht werden kann, dass der Core bzw. im schlimmsten Falle andere Clients % Mischung Komponentenebene mit Applikationsebene, finde ich nicht so toll.
keinen direkten Zugriff auf die Datenbank erhalten, sondern nur auf die spezifizierten und notwendigen Funktionen. % was sind spezifischere und notwendige Funktionen

\subsection{Synchronisation Services}
Die Synchronisationskomponente arbeitet sehr eng mit dem Core zusammen. Der Core übermittelt beispielsweise eine Änderung einer Datei, welche durch den User bzw. automatisch (je nach Einstellung) bestätigt wurde.% Implementationsdetail: Der Synchronisation ist es egal ob irgendwas bestätigt wurde. 
 Die Synchronisationskomponente beinhaltet nun verschiedene Strategien, wie diese Änderungen an andere
Projektmitglieder/Clients propagiert werden. 

\subsection{File System Services}
Die File System Services sind die Schnittstelle des Programmes zum Dateisystem des Benutzers. Dieser Service kapselt den kompleten Zugriff auf Dateien im Dateisystem, sodass diese vom Programm wie jegliche andere Objekte (z.B. Notizen) verwendet werden können. Außerdem kann der Dateisystem Service durch
entsprechende Strategien feststellen, ob Dateien geändert wurden oder in die Projektordnerstruktur kopiert wurden und dies dem Core mitteilen, welcher wiederum entsprechende Aktionen veranlasst.

\subsection{Network Service} % Könnte man daraus "Interclient Communication" machen? Ich will mich ja nicht mit irgendwelchen netzwerken herumschlagen, sondern mein ziel ist es mit anderen clients zu kommunizieren. Das würde viel "Netzwerk Code" aus dem Core hierher verschieben.
Der Network Service behandelt alle Netzwerktätigkeiten des Programmes. Der Service kapselt beispielsweise
vollständig die Kommunikation der Clients auf Netzwerkebene und gibt die entsprechenden Nachrichten an
den Core weiter. So ist es leicht möglich, verschiedene Netzwerkbackends (z.B. XMPP oder RMI) zu unterstützen,
welche für den Core und somit für den Benutzer transparent sind. Außerdem wird die Authentifizierung der
Nutzer in dieser Komponente durchgeführt.
% Ich habe bei Client Authentifizierung ein schlechtes Gefühl. Wenn wir nicht mit XMPP arbeiten, wie werden die Clients dann Authentifiziert?

